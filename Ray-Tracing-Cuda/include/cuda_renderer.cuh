#pragma once
#include <cuda.h>
#include "cuda_helpers.cuh"
#include <device_launch_parameters.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <memory>
#include <limits>
#include <random>
#include "vec3.cuh"
#include "ray.cuh"
#include "sphere.cuh"
#include "hitable.cuh"
#include "hitable_list.cuh"
#include "camera.cuh"
#include "material.cuh"
#include "random_helpers.cuh"

namespace cuda_renderer {
#define RM(row,col,w) row*w+col
#define CM(row,col,h) col*h+row

#define RM3(row,col,w) 3*row*w+3*col
#define CM3(row,col,h) 3*col*h+3*row

	void write_ppm_image(std::vector<rgb> colors, int w, int h, std::string filename) {
		std::ofstream myfile;
		myfile.open(filename + ".ppm");
		myfile << "P3\n" << w << " " << h << "\n255\n";
		for (int i = 0; i < h; i++) {
			for (int j = 0; j < w; j++) {
				auto color = colors[RM(i, j, w)];
				myfile << color.r()*255.99 << " " << color.g()*255.99 << " " << color.b()*255.99 << std::endl;
			}
		}
		myfile.close();
	}

	__global__ void render(float *fb, int max_x, int max_y) {
		int row = threadIdx.x + blockIdx.x * blockDim.x;
		int col = threadIdx.y + blockIdx.y * blockDim.y;
		if ((col >= max_x) || (row >= max_y)) return;
		int pixel_index = RM3(row,col, max_x);
		fb[pixel_index + 0] = float(col) / float(max_x);
		fb[pixel_index + 1] = float(max_y-row) / float(max_y);
		fb[pixel_index + 2] = 0.2;
	}

	std::vector<rgb> cuda_ray_render(int w, int h, int samples) {
		size_t fb_size = 3 * w*h * sizeof(float);
		float *fb;
		checkCudaErrors(cudaMallocManaged((void **)&fb, fb_size));
		int tx = 8, ty = 8;

		dim3 blocks(h / ty + 1, w / tx + 1);
		dim3 threads(tx, ty);
		// <Auto-Generated>
		// This is here so CodeMaid doesn't reorganize this document
		render<<<blocks, threads>>>(fb, w, h);
		// </Auto-Generated>
		checkCudaErrors(cudaGetLastError());
		checkCudaErrors(cudaDeviceSynchronize());

		auto colors = std::vector<rgb>(w*h);
		//auto c = camera();
		//auto world = std::make_shared<hitable_list>();
		//world->add_hitable(std::make_shared<sphere>(vec3(0, 0, -1), 0.5f, std::make_shared<lambertian>(vec3(0.8f, 0.3f, 0.3f))));
		//world->add_hitable(std::make_shared<sphere>(vec3(0, -100.5, -1), 100.0f, std::make_shared<lambertian>(vec3(0.8f, 0.8f, 0.0f))));
		//world->add_hitable(std::make_shared<sphere>(vec3(1, 0, -1), 0.5f, std::make_shared<metal>(vec3(0.8f, 0.6f, 0.2f), 0.3f)));
		//world->add_hitable(std::make_shared<sphere>(vec3(-1, 0, -1), 0.5f, std::make_shared<dielectric>(1.5f)));
		//world->add_hitable(std::make_shared<sphere>(vec3(-1, 0, -1), -0.45f, std::make_shared<dielectric>(1.5f)));

		// Output FB as Image
		std::cout << "P3\n" << h << " " << w << "\n255\n";
		for (int i = 0; i < h; i++) {
			for (int j = 0; j < w; j++) {
				size_t pixel_index = RM3(i, j, w);
				float r = fb[pixel_index + 0];
				float g = fb[pixel_index + 1];
				float b = fb[pixel_index + 2];
				colors[RM(i, j, w)] = rgb(r, g, b);
			}
		}
		checkCudaErrors(cudaFree(fb));
		return colors;
	}
}