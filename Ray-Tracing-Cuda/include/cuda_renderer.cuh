#pragma once
// <Auto-Generated>
// This is here so CodeMaid doesn't reorganize this document
// </Auto-Generated>

#include <cuda.h>
#include <curand_kernel.h>
#include <device_launch_parameters.h>
#include <iostream>
#include <fstream>
#include <time.h>
#include <vector>
#include <memory>
#include <limits>
#include <random>
#include "cuda_helpers.cuh"
#include "vec3.cuh"
#include "ray.cuh"
#include "sphere.cuh"
#include "hitable.cuh"
#include "hitable_list.cuh"
#include "camera.cuh"
#include "material.cuh"
#include "random_helpers.cuh"

namespace cuda_renderer {
#define RM(row,col,w) row*w+col
#define CM(row,col,h) col*h+row

#define RM3(row,col,w) 3*row*w+3*col
#define CM3(row,col,h) 3*col*h+3*row

	void write_ppm_image(std::vector<rgb> colors, int w, int h, std::string filename) {
		std::ofstream myfile;
		myfile.open(filename + ".ppm");
		myfile << "P3\n" << w << " " << h << "\n255\n";
		for (int i = 0; i < h; i++) {
			for (int j = 0; j < w; j++) {
				auto color = colors[RM(i, j, w)];
				myfile << color.r()*255.99 << " " << color.g()*255.99 << " " << color.b()*255.99 << std::endl;
			}
		}
		myfile.close();
	}

	__device__ vec3 color(const ray& r, hitable **world, curandState *local_rand_state) {
		ray cur_ray = r;
		vec3 cur_attenuation = vec3(1.0f,1.0f,1.0f);
		for (int i = 0; i < 50; i++) {
			hit_record rec;
			if ((*world)->hit(cur_ray, 0.001f, FLT_MAX, rec)) {
				ray scattered;
				vec3 attenuation;
				if (rec.mat_ptr->scatter(cur_ray, rec, attenuation, scattered, local_rand_state)) {
					cur_attenuation *= attenuation;
					cur_ray = scattered;
				}
			}
			else {
				vec3 unit_direction = unit_vector(cur_ray.direction());
				float t = 0.5f*(unit_direction.y() + 1.0f);
				vec3 c = vec3(1.0, 1.0, 1.0)*(1.0f - t) + vec3(0.5, 0.7, 1.0)*t;
				return c * cur_attenuation;
			}
		}
		return vec3(0.0, 0.0, 0.0); // exceeded recursion
	}

	__global__ void render(vec3 *fb, int max_x, int max_y, int samples, camera ** camera, hitable **world, curandState *rand_state) {
		int row = threadIdx.x + blockIdx.x * blockDim.x;
		int col = threadIdx.y + blockIdx.y * blockDim.y;
		if ((col >= max_x) || (row >= max_y)) return;
		int pixel_index = RM(row,col, max_x);
		curandState local_rand_state = rand_state[pixel_index];
		rgb pix(0, 0, 0);
		for (int s = 0; s < samples; s++) {
			float u = float(col + curand_uniform(&local_rand_state)) / float(max_x);
			float v = float(max_y-row + curand_uniform(&local_rand_state)) / float(max_y);
			ray r = (*camera)->get_ray(u, v);
			pix += color(r, world, rand_state);
		}
		pix = (pix / float(samples)).v_sqrt();
		fb[pixel_index] = pix;
	}

	__global__ void render_init(int max_x, int max_y, curandState *rand_state) {
		int row = threadIdx.x + blockIdx.x * blockDim.x;
		int col = threadIdx.y + blockIdx.y * blockDim.y;
		if ((col >= max_x) || (row >= max_y)) return;
		int pixel_index = RM(row, col, max_x);
		//Each thread gets same seed, a different sequence number, no offset
		curand_init(1984, pixel_index, 0, &rand_state[pixel_index]);
	}

	__global__ void create_world(hitable **d_list, hitable **d_world, camera **d_camera) {
		if (threadIdx.x == 0 && blockIdx.x == 0) {
			d_list[0] = new sphere(vec3(0, 0, -1), 0.5,
				new lambertian(vec3(0.1, 0.2, 0.5)));
			d_list[1] = new sphere(vec3(0, -100.5, -1), 100,
				new lambertian(vec3(0.8, 0.8, 0.0)));
			d_list[2] = new sphere(vec3(1, 0, -1), 0.5,
				new metal(vec3(0.8, 0.6, 0.2), 0.0));
			d_list[3] = new sphere(vec3(-1, 0, -1), 0.5,
				new dielectric(1.5f));
			d_list[4] = new sphere(vec3(-1, 0, -1), -0.45,
				new dielectric(1.5f));
			*d_world = new hitable_list(d_list, 5);
			*d_camera = new camera();
		}
	}

	__global__ void free_world(hitable **d_list, hitable **d_world, camera ** d_camera) {
		for (int i = 0; i < 5; i++) {
			delete ((sphere *)d_list[i])->_material;
			delete d_list[i];
		}
		delete *d_world;
		delete *d_camera;
	}

	std::vector<rgb> cuda_ray_render(int w, int h, int samples) {

		curandState *d_rand_state;
		checkCudaErrors(cudaMalloc((void **)&d_rand_state, w*h * sizeof(curandState)));
		hitable **d_list;
		checkCudaErrors(cudaMalloc((void **)& d_list, 5 * sizeof(hitable *)));
		hitable **d_world;
		checkCudaErrors(cudaMalloc((void **)& d_world, sizeof(hitable *)));
		camera **d_camera;
		checkCudaErrors(cudaMalloc((void **)&d_camera, sizeof(camera *)));
		create_world<<<1, 1>>>(d_list, d_world, d_camera);
		checkCudaErrors(cudaGetLastError());
		checkCudaErrors(cudaDeviceSynchronize());

		size_t fb_size = w * h * sizeof(vec3);
		vec3 *fb;
		checkCudaErrors(cudaMallocManaged((void **)&fb, fb_size));

		clock_t start, stop;
		start = clock();

		int tx = 8, ty = 8;
		dim3 blocks(h / ty + 1, w / tx + 1);
		dim3 threads(tx, ty);

		render_init<<<blocks, threads>>>(w, h, d_rand_state);
		checkCudaErrors(cudaGetLastError());
		checkCudaErrors(cudaDeviceSynchronize());
		render<<<blocks, threads>>>(fb, w, h, samples, d_camera, d_world, d_rand_state);
		checkCudaErrors(cudaGetLastError());
		checkCudaErrors(cudaDeviceSynchronize());

		stop = clock();
		double timer_seconds = ((double)(stop - start)) / CLOCKS_PER_SEC;
		std::cerr << "took " << timer_seconds << " seconds.\n";



		auto colors = std::vector<rgb>(w*h);
		//auto world = std::make_shared<hitable_list>();
		//world->add_hitable(std::make_shared<sphere>(vec3(0, 0, -1), 0.5f, std::make_shared<lambertian>(vec3(0.8f, 0.3f, 0.3f))));
		//world->add_hitable(std::make_shared<sphere>(vec3(0, -100.5, -1), 100.0f, std::make_shared<lambertian>(vec3(0.8f, 0.8f, 0.0f))));
		//world->add_hitable(std::make_shared<sphere>(vec3(1, 0, -1), 0.5f, std::make_shared<metal>(vec3(0.8f, 0.6f, 0.2f), 0.3f)));
		//world->add_hitable(std::make_shared<sphere>(vec3(-1, 0, -1), 0.5f, std::make_shared<dielectric>(1.5f)));
		//world->add_hitable(std::make_shared<sphere>(vec3(-1, 0, -1), -0.45f, std::make_shared<dielectric>(1.5f)));

		std::cout << "P3\n" << h << " " << w << "\n255\n";
		for (int i = 0; i < h; i++) {
			for (int j = 0; j < w; j++) {
				const size_t pixel_index = RM(i, j, w);
				colors[pixel_index] = fb[pixel_index];
			}
		}
		checkCudaErrors(cudaDeviceSynchronize());
		free_world<<<1, 1>>>(d_list, d_world, d_camera);
		checkCudaErrors(cudaGetLastError());
		checkCudaErrors(cudaFree(d_list));
		checkCudaErrors(cudaFree(d_world));
		checkCudaErrors(cudaFree(fb));
		return colors;
	}
}